const express = require('express');
const { exec } = require('child_process');
const fs = require('fs');
const app = express();
const port = 3000;

app.use(express.json());
app.use(express.static('.'));

const profiles = []; // Temporary storage for test profiles

app.post('/run-test', (req, res) => {
    const { tps, txNumber, contract, users, iot, testMethod, testType, maxDistance, batchSize, timeout, channels } = req.body;

    // Update docker-compose.yml for batchSize
    let dockerCompose = fs.readFileSync('docker-compose.yml', 'utf8');
    dockerCompose = dockerCompose.replace(/MaxMessageCount: \d+/, `MaxMessageCount: ${batchSize}`);
    fs.writeFileSync('docker-compose.yml', dockerCompose);

    // Update myAssetBenchmark.yaml
    let benchmarkContent = `
test:
  name: 6g-fabric-benchmark
  description: Benchmark for 6G Fabric Network
  workers:
    type: local
    number: 1
  rounds:
    ${testType === 'invoke' || testType === 'both' ? `
    - label: invoke
      description: Test invoke performance
      txNumber: ${txNumber}
      rateControl:
        type: fixed-rate
        opts:
          tps: ${tps}
      workload:
        module: workload/${contract}.js` : ''}
    ${testType === 'query' || testType === 'both' ? `
    - label: query
      description: Test query performance
      txNumber: ${txNumber}
      rateControl:
        type: fixed-rate
        opts:
          tps: ${tps}
      workload:
        module: workload/${contract}.js` : ''}
  monitors:
    resource:
      - module: docker
        options:
          interval: 1
          containers:
            - orderer1.example.com
            - peer0.org1.example.com
            - peer0.org2.example.com
            - peer0.org3.example.com
            - peer0.org4.example.com
            - peer0.org5.example.com
            - peer0.org6.example.com
            - peer0.org7.example.com
            - peer0.org8.example.com
`;
    fs.writeFileSync('caliper-workspace/benchmarks/myAssetBenchmark.yaml', benchmarkContent);

    // Update workload.js for users, IoT, and maxDistance
    let workloadContent = fs.readFileSync(`caliper-workspace/workload/${contract}.js`, 'utf8');
    workloadContent = workloadContent.replace(/const entityID = .*/g, `const entityID = \`user\${this.workerIndex}_\${Math.floor(Math.random() * ${users})}\``);
    workloadContent = workloadContent.replace(/const antennaID = .*/g, `const antennaID = \`Antenna\${Math.floor(Math.random() * ${iot})}\``);
    if (contract.includes('LocationBased')) {
        workloadContent = workloadContent.replace(/timeout: \d+/g, `timeout: ${timeout}`);
        workloadContent += `
        async validateDistance() {
            const args = {
                contractId: this.chaincodeID,
                contractFunction: 'Validate${contract}Distance',
                contractArguments: [entityID, '${maxDistance}'],
                readOnly: true
            };
            await this.sutAdapter.sendRequests({
                contractId: this.chaincodeID,
                channel: this.channel,
                args: args,
                timeout: ${timeout}
            });
        }`;
    }
    fs.writeFileSync(`caliper-workspace/workload/${contract}.js`, workloadContent);

    // Run test for selected channels
    let command = '';
    channels.forEach(channel => {
        if (testMethod === 'Caliper' || testMethod === 'Both') {
            command += `cd caliper-workspace && npx caliper launch manager --caliper-workspace . --caliper-networkconfig networks/networkConfig.yaml --caliper-benchconfig benchmarks/myAssetBenchmark.yaml --caliper-flow-only-test; `;
        }
        if (testMethod === 'Tape' || testMethod === 'Both') {
            command += `node ../generateTapeArgs.js && tape --config ../tape-config.yaml; `;
        }
    });

    exec(command, (error, stdout, stderr) => {
        if (error) {
            res.status(500).send({ error: stderr });
            return;
        }
        res.send({ output: stdout });
    });
});

app.get('/network-stats', (req, res) => {
    // Mock data for dashboard (replace with actual Fabric SDK calls)
    res.json({
        blockCount: 100, // Replace with actual block count
        txCount: 500, // Replace with actual transaction count
        tpsData: { labels: ['1m', '2m', '3m'], values: [5, 7, 6] },
        latencyData: { labels: ['1m', '2m', '3m'], values: [10, 12, 11] }
    });
});

app.get('/blocks', (req, res) => {
    // Mock data (replace with Fabric SDK to fetch blocks)
    res.json([
        { height: 1, hash: 'abc123', txCount: 10, timestamp: '2025-07-17T14:00:00Z' },
        { height: 2, hash: 'def456', txCount: 15, timestamp: '2025-07-17T14:01:00Z' }
    ]);
});

app.get('/transactions', (req, res) => {
    // Mock data (replace with Fabric SDK to fetch transactions)
    res.json([
        { id: 'tx1', contract: 'LocationBasedAssignment', channel: 'GeneralOperationsChannel', timestamp: '2025-07-17T14:00:00Z' },
        { id: 'tx2', contract: 'AuthenticateUser', channel: 'SecurityChannel', timestamp: '2025-07-17T14:01:00Z' }
    ]);
});

app.get('/peers', (req, res) => {
    // Mock data (replace with Docker API or Fabric SDK)
    res.json([
        { name: 'peer0.org1.example.com', status: 'Running' },
        { name: 'peer0.org2.example.com', status: 'Stopped' }
    ]);
});

app.get('/chaincodes', (req, res) => {
    // Mock data (replace with Fabric SDK)
    res.json([
        { name: 'LocationBasedAssignment', version: '1.0', channel: 'GeneralOperationsChannel' },
        { name: 'AuthenticateUser', version: '1.0', channel: 'SecurityChannel' }
    ]);
});

app.post('/start-peer/:peer', (req, res) => {
    exec(`docker start ${req.params.peer}`, (error, stdout, stderr) => {
        if (error) return res.status(500).send({ error: stderr });
        res.json({ message: `Peer ${req.params.peer} started` });
    });
});

app.post('/stop-peer/:peer', (req, res) => {
    exec(`docker stop ${req.params.peer}`, (error, stdout, stderr) => {
        if (error) return res.status(500).send({ error: stderr });
        res.json({ message: `Peer ${req.params.peer} stopped` });
    });
});

app.post('/install-chaincode/:cc', (req, res) => {
    exec(`docker exec peer0.org1.example.com peer chaincode install -n ${req.params.cc} -v 1.0 -p github.com/chaincode/${req.params.cc}`, (error, stdout, stderr) => {
        if (error) return res.status(500).send({ error: stderr });
        res.json({ message: `Chaincode ${req.params.cc} installed` });
    });
});

app.post('/upgrade-chaincode/:cc', (req, res) => {
    exec(`docker exec peer0.org1.example.com peer chaincode upgrade -o orderer1.example.com:7050 --tls --cafile /crypto-config/ordererOrganizations/example.com/orderers/orderer1.example.com/msp/tlscacerts/tlsca.example.com-cert.pem -C GeneralOperationsChannel -n ${req.params.cc} -v 1.1 -c '{"Args":["init"]}'`, (error, stdout, stderr) => {
        if (error) return res.status(500).send({ error: stderr });
        res.json({ message: `Chaincode ${req.params.cc} upgraded` });
    });
});

app.get('/download-report', (req, res) => {
    res.download('caliper-workspace/report.html');
});

app.get('/download-tape-log', (req, res) => {
    res.download('tape.log');
});

app.post('/save-profile', (req, res) => {
    profiles.push(req.body);
    res.json({ message: `Profile ${req.body.name} saved` });
});

app.get('/load-profiles', (req, res) => {
    res.json(profiles);
});

app.get('/load-profile/:name', (req, res) => {
    const profile = profiles.find(p => p.name === req.params.name);
    if (!profile) return res.status(404).send({ error: 'Profile not found' });
    res.json(profile);
});

app.listen(port, () => {
    console.log(`Server running at http://165.232.71.90:${port}`);
});
